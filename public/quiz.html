<!DOCTYPE html>
<html class="light" lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>Quiz - Chinese Learning</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="/api-config.js?v=2"></script>
  <script src="/auth.js"></script>
  <script src="/study-tracker.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" media="print" onload="this.media='all'"/>
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            "primary": "#4A90E2",
            "secondary": "#50E3C2",
            "accent": "#F5A623",
            "background-light": "#F8F9FA",
            "background-dark": "#101c22",
          },
          fontFamily: {
            "display": ["Work Sans", "sans-serif"]
          },
        },
      },
    }
  </script>
  <style>
    * {
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }

    .option-card {
      background: white;
      border: 2px solid #e5e7eb;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .option-card:active {
      transform: scale(0.98);
    }

    .option-card.selected {
      border-color: #448fe4;
      background: rgba(68, 143, 228, 0.05);
    }

    .option-card.correct {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.05);
    }

    .option-card.wrong {
      border-color: #ef4444;
      background: rgba(239, 68, 68, 0.05);
    }

    .option-btn {
      transition: all 0.3s ease;
    }

    .option-btn.correct {
      background-color: #50E3C2;
      color: white;
      border-color: #50E3C2;
    }

    .option-btn.incorrect {
      background-color: #ef4444;
      color: white;
      border-color: #ef4444;
    }

    .progress-bar {
      background: #e5e7eb;
      height: 6px;
      border-radius: 999px;
      overflow: hidden;
    }

    .progress-fill {
      background: linear-gradient(90deg, #448fe4, #50b8e4);
      height: 100%;
      transition: width 0.3s ease;
    }

    .audio-player {
      background: linear-gradient(135deg, rgba(68, 143, 228, 0.1), rgba(80, 227, 194, 0.1));
      border: 2px solid rgba(68, 143, 228, 0.2);
    }

    .reading-passage {
      background: #f8f9fa;
      border-left: 4px solid #448fe4;
      padding: 16px;
      border-radius: 12px;
    }

    .input-box {
      background: #ffffff;
      border: 2px solid #e5e7eb;
      padding: 14px 18px;
      border-radius: 12px;
      font-size: 16px;
      width: 100%;
      transition: all 0.2s ease;
      color: #1a1a1a;
      font-family: 'Work Sans', sans-serif;
    }

    .input-box::placeholder {
      color: #9ca3af;
    }

    .input-box:focus {
      outline: none;
      border-color: #448fe4;
      background: rgba(68, 143, 228, 0.03);
      box-shadow: 0 0 0 3px rgba(68, 143, 228, 0.1);
    }

    .dark .input-box {
      background: #1e2732;
      border-color: #374151;
      color: #ffffff;
    }

    .dark .input-box::placeholder {
      color: #6b7280;
    }

    .dark .input-box:focus {
      background: rgba(68, 143, 228, 0.1);
      border-color: #448fe4;
    }

    .word-chip {
      background: white;
      border: 2px solid #e5e7eb;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: move;
      user-select: none;
      transition: all 0.2s ease;
    }

    .word-chip.selected {
      border-color: #448fe4;
      background: rgba(68, 143, 228, 0.1);
    }

    .word-chip:active {
      transform: scale(0.95);
    }

    .drop-zone {
      min-height: 60px;
      border: 2px dashed #e5e7eb;
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .drop-zone.active {
      border-color: #448fe4;
      background: rgba(68, 143, 228, 0.05);
    }

    .error-text {
      position: relative;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
    }

    .error-text.error {
      background: rgba(239, 68, 68, 0.1);
      border-bottom: 2px wavy #ef4444;
    }

    .error-text.selected {
      background: rgba(68, 143, 228, 0.2);
    }

    .record-button {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .record-button:active {
      transform: scale(0.95);
    }

    .record-button.recording {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3); }
      50% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.6); }
    }

    .image-option {
      border: 3px solid #e5e7eb;
      border-radius: 16px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .image-option.selected {
      border-color: #448fe4;
      box-shadow: 0 4px 12px rgba(68, 143, 228, 0.3);
    }

    .image-option:active {
      transform: scale(0.97);
    }

    /* Custom Audio Player Styling */
    audio {
      width: 100%;
      height: 50px;
      border-radius: 12px;
      outline: none;
    }

    audio::-webkit-media-controls-panel {
      background: linear-gradient(135deg, #4A90E2 0%, #50E3C2 100%);
      border-radius: 12px;
    }

    audio::-webkit-media-controls-play-button,
    audio::-webkit-media-controls-pause-button {
      background-color: white;
      border-radius: 50%;
    }

    audio::-webkit-media-controls-current-time-display,
    audio::-webkit-media-controls-time-remaining-display {
      color: white;
      text-shadow: none;
      font-weight: 500;
    }

    audio::-webkit-media-controls-timeline {
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 25px;
      margin: 0 10px;
    }

    audio::-webkit-media-controls-volume-slider {
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 25px;
    }

    /* Firefox */
    audio::-moz-range-track {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 25px;
    }

    audio::-moz-range-thumb {
      background: white;
      border-radius: 50%;
    }

  </style>
</head>
<body class="bg-background-light dark:bg-background-dark font-display">
  <div class="relative flex min-h-screen w-full flex-col overflow-x-hidden">
    <!-- Header -->
    <header class="sticky top-0 z-50 bg-surface-light/95 dark:bg-surface-dark/95 backdrop-blur-md border-b border-border-light dark:border-border-dark">
      <div class="px-4 py-3">
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-3">
            <button id="backBtn" class="p-1.5 rounded-lg hover:bg-black/5 dark:hover:bg-white/5">
              <span class="material-symbols-outlined text-gray-500">close</span>
            </button>
            <div>
              <div class="flex items-center gap-2">
                <span id="quizTitle" class="text-sm font-semibold text-text-light dark:text-text-dark">Quiz</span>
                <span id="questionType" class="text-xs px-2 py-0.5 rounded-full bg-primary/15 text-primary font-medium"></span>
              </div>
              <p class="text-xs text-gray-500 dark:text-gray-400 mt-0.5">Question <span id="currentQuestionNum">1</span>/<span id="totalQuestionsNum">1</span></p>
            </div>
          </div>
        </div>
        <div class="progress-bar">
          <div id="progressBar" class="progress-fill" style="width: 0%"></div>
        </div>
      </div>
    </header>

    <main class="px-4 py-5 pb-24">

      <!-- Question Heading (no card background) -->
      <div id="questionCard" class="mb-6">
        <h1 class="text-xl font-bold mb-4 text-text-light dark:text-text-dark" id="questionHeading">What does this mean?</h1>

        <!-- Chinese Text Display -->
        <div id="chineseContainer" class="hidden mb-6">
          <h2 class="text-5xl font-bold text-center text-primary mb-2 break-words" id="questionChinese"></h2>
          <p class="text-lg text-center text-gray-500 dark:text-gray-400 break-words" id="questionPinyin"></p>
        </div>

        <!-- Image (shown only when image exists) -->
        <div id="imageContainer" class="hidden mb-6">
          <img id="questionImage" src="" alt="Question image" class="w-full max-w-md mx-auto rounded-lg shadow-md">
        </div>

        <!-- Audio Player (shown only when audio exists) -->
        <div id="audioPlayerContainer" class="hidden mb-6">
          <button onclick="document.getElementById('questionAudio').play()" class="w-full flex items-center justify-center gap-2 px-6 py-3.5 rounded-xl bg-primary/10 dark:bg-primary/20 text-primary dark:text-primary hover:bg-primary/20 dark:hover:bg-primary/30 transition-all">
            <span class="material-symbols-outlined">volume_up</span>
            <span class="font-semibold">Play Audio</span>
          </button>
          <audio id="questionAudio" class="hidden">
            <source id="audioSource" type="audio/mpeg">
          </audio>
        </div>
      </div>

      <!-- Options -->
      <div class="space-y-3 mb-6" id="optionsContainer"></div>

      <!-- Action Buttons -->
      <div class="fixed bottom-0 left-0 right-0 p-4 bg-surface-light/95 dark:bg-surface-dark/95 backdrop-blur-md border-t border-border-light dark:border-border-dark">
        <div class="flex gap-3">
          <button id="skipBtn" class="flex-1 px-6 py-3 rounded-xl border-2 border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 font-semibold hover:bg-gray-50 dark:hover:bg-gray-800 active:scale-95 transition-all">
            Skip
          </button>
          <button id="nextBtn" disabled class="flex-1 px-6 py-3 rounded-xl bg-primary text-white font-semibold disabled:opacity-50 disabled:cursor-not-allowed hover:bg-primary/90 active:scale-95 transition-all">
            Next
          </button>
        </div>
      </div>

    </main>
  </div>

  <script>
    // Initialize Telegram WebApp
    const tg = window.Telegram.WebApp;
    tg.expand();
    tg.ready();

    // State
    let currentQuestion = 1;
    let totalQuestions = null; // Will be determined dynamically based on available questions
    let stats = { correct: 0, incorrect: 0 };
    let currentAnswer = null;
    let currentQuestionData = null;
    let answered = false;
    let usedQuestionIds = []; // Track used questions to avoid duplicates
    let quizComplete = false;

    // Get HSK level from URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const hskLevel = urlParams.get('level');

    // Elements
    const questionChinese = document.getElementById('questionChinese');
    const questionPinyin = document.getElementById('questionPinyin');
    const optionsContainer = document.getElementById('optionsContainer');
    const nextBtn = document.getElementById('nextBtn');
    const skipBtn = document.getElementById('skipBtn');
    const backBtn = document.getElementById('backBtn');

    // Set quiz title based on HSK level
    const quizTitle = document.getElementById('quizTitle');
    if (quizTitle && hskLevel) {
      quizTitle.textContent = `HSK ${hskLevel} Quiz`;
    }

    // Skip button handler
    if (skipBtn) {
      skipBtn.addEventListener('click', async () => {
        // Skip current question without answering
        currentQuestion++;
        try {
          await loadQuestion();
        } catch (error) {
          console.log('No more questions available, finishing quiz');
          quizComplete = true;
          totalQuestions = currentQuestion - 1;
          finishQuiz();
        }
      });
    }

    // Load question from API
    async function loadQuestion() {
      try {
        // Check if API_CONFIG is loaded
        if (typeof API_CONFIG === 'undefined') {
          throw new Error('API_CONFIG not loaded yet');
        }

        // Build URL with level parameter and used question IDs
        let url = API_CONFIG.url(API_CONFIG.endpoints.quiz);
        const params = new URLSearchParams();
        if (hskLevel) {
          params.append('level', hskLevel);
        }
        if (usedQuestionIds.length > 0) {
          params.append('exclude', usedQuestionIds.join(','));
        }
        if (params.toString()) {
          url += '?' + params.toString();
        }

        console.log('Fetching quiz from:', url);

        const response = await fetch(url, {
          headers: telegramAuth.getHeaders()
        });

        const data = await response.json();

        if (!response.ok) {
          // Throw error with message from response
          throw new Error(data.error || `HTTP error! status: ${response.status}`);
        }

        // Set total questions from API response (if not already set)
        if (totalQuestions === null && data.totalQuestions) {
          totalQuestions = data.totalQuestions;
          console.log('Total questions available:', totalQuestions);
        }

        console.log('Question loaded:', data.id, 'Previously used:', usedQuestionIds);

        // Parse question text to extract audio URL, image URL, and Chinese text if present
        let questionText = data.question || '';
        let audioUrl = '';
        let imageUrl = '';

        // Extract audio URL from [audio: url] format
        const audioMatch = questionText.match(/\[audio:\s*(.+?)\]/);
        if (audioMatch) {
          audioUrl = audioMatch[1];
          questionText = questionText.replace(/\[audio:\s*.+?\]/, '').trim();
        }

        // Extract image URL from [image: url] format
        const imageMatch = questionText.match(/\[image:\s*(.+?)\]/);
        if (imageMatch) {
          imageUrl = imageMatch[1];
          questionText = questionText.replace(/\[image:\s*.+?\]/, '').trim();
        }

        // Extract Chinese text from " - ‰∏≠Êñá" format if present (do this BEFORE adding sentence/compQuestion)
        // Skip this for fill_gap questions where the sentence is shown in the card
        let chineseMatch = null;
        if (data.questionType !== 'fill_gap' && data.questionType !== 'fill_in_gap') {
          chineseMatch = questionText.match(/\s+-\s+(.+)$/);
          if (chineseMatch) {
            questionText = questionText.replace(/\s+-\s+.+$/, '').trim();
          }
        }

        // Remove transcript tag from audio_comprehension (transcript is shown after answer)
        // Use greedy match to handle multi-line transcripts
        questionText = questionText.replace(/\[transcript:[^\]]*\]/g, '').trim();

        // Extract and display comprehension question if present (for audio_comprehension type)
        const compQuestionMatch = questionText.match(/\[compQuestion:\s*([^\]]+)\]/);
        if (compQuestionMatch) {
          const compQuestion = compQuestionMatch[1];
          questionText = questionText.replace(/\[compQuestion:[^\]]+\]/, '').trim();
          // Append comprehension question to the main question text
          if (questionText) {
            questionText += ' - ' + compQuestion;
          } else {
            questionText = compQuestion;
          }
        }

        // Extract and display sentence for grammar_choice type
        const sentenceMatch = questionText.match(/\[sentence:\s*([^\]]+)\]/);
        if (sentenceMatch) {
          const sentence = sentenceMatch[1];
          questionText = questionText.replace(/\[sentence:[^\]]+\]/, '').trim();
          // Display sentence prominently
          if (questionText) {
            questionText += ' - ' + sentence;
          } else {
            questionText = sentence;
          }
        }

        // For fill_gap questions, extract sentence (shown in card) from heading
        // Format: "Complete the sentence: - Êàë ___ Â≠¶Áîü (I ___ a student.)"
        if (data.questionType === 'fill_gap' || data.questionType === 'fill_in_gap') {
          const fillGapMatch = questionText.match(/^(.+?)\s*-\s*(.+)$/);
          if (fillGapMatch) {
            // Keep only the heading part, sentence will be shown in renderFillGapQuestion
            questionText = fillGapMatch[1].trim();
          }
        }

        // Remove passage tag from cloze_test (passage is shown in the question rendering)
        questionText = questionText.replace(/\[passage:.+?\]$/g, '').trim();

        // Set question heading
        const questionHeading = document.getElementById('questionHeading');
        const chineseContainer = document.getElementById('chineseContainer');
        const questionChinese = document.getElementById('questionChinese');
        const questionPinyin = document.getElementById('questionPinyin');

        // Separate heading from Chinese text
        // If we extracted Chinese text from the question, use the clean question as heading
        let headingText = questionText;
        let chineseText = '';

        // Check if there's Chinese text extracted
        if (chineseMatch) {
          chineseText = chineseMatch[1];
        }

        if (questionHeading) {
          questionHeading.textContent = headingText || 'What does this mean?';
        }

        // Show Chinese text if it exists
        if (chineseText) {
          questionChinese.textContent = chineseText;
          questionPinyin.textContent = data.pinyin || '';
          chineseContainer.classList.remove('hidden');
        } else {
          chineseContainer.classList.add('hidden');
        }

        // Handle image display
        const imageContainer = document.getElementById('imageContainer');
        const questionImage = document.getElementById('questionImage');

        if (imageUrl) {
          questionImage.src = imageUrl;
          imageContainer.classList.remove('hidden');
        } else {
          imageContainer.classList.add('hidden');
        }

        // Handle audio player
        const audioPlayerContainer = document.getElementById('audioPlayerContainer');
        const audioSource = document.getElementById('audioSource');
        const questionAudio = document.getElementById('questionAudio');

        if (audioUrl) {
          audioSource.src = audioUrl;
          questionAudio.load();
          audioPlayerContainer.classList.remove('hidden');
        } else {
          audioPlayerContainer.classList.add('hidden');
        }

        currentAnswer = data.correctAnswer;
        currentQuestionData = data;

        // Track this question ID to avoid duplicates
        if (data.id && !usedQuestionIds.includes(data.id)) {
          usedQuestionIds.push(data.id);
          console.log('Added to used list. Total used:', usedQuestionIds.length);
        } else if (data.id) {
          console.warn('DUPLICATE DETECTED! Question ID:', data.id, 'already in list:', usedQuestionIds);
        }

        // Clear options container
        optionsContainer.innerHTML = '';

        // Get question card element
        const questionCard = document.getElementById('questionCard');

        // Check question type and render accordingly
        switch(data.questionType) {
          case 'matching':
            questionCard.classList.remove('hidden');
            renderMatchingQuestion(data);
            break;
          case 'cloze_test':
            // Hide the main question card for cloze tests (heading is in render function)
            questionCard.classList.add('hidden');
            renderClozeTestQuestion(data);
            break;
          case 'fill_gap':
          case 'fill_in_gap':
            questionCard.classList.remove('hidden');
            renderFillGapQuestion(data);
            break;
          case 'true_false':
            questionCard.classList.remove('hidden');
            renderTrueFalseQuestion(data);
            break;
          case 'sentence_ordering':
            questionCard.classList.remove('hidden');
            renderSentenceOrderingQuestion(data);
            break;
          case 'grammar_choice':
            questionCard.classList.remove('hidden');
            renderGrammarChoiceQuestion(data);
            break;
          case 'error_correction':
            questionCard.classList.remove('hidden');
            renderErrorCorrectionQuestion(data);
            break;
          case 'dictation':
            questionCard.classList.remove('hidden');
            renderDictationQuestion(data);
            break;
          case 'audio_comprehension':
            questionCard.classList.remove('hidden');
            renderAudioComprehensionQuestion(data);
            break;
          case 'audio_to_word':
            questionCard.classList.remove('hidden');
            renderAudioToWordQuestion(data);
            break;
          case 'repeat_after_me':
            questionCard.classList.remove('hidden');
            renderRepeatAfterMeQuestion(data);
            break;
          case 'image_association':
            questionCard.classList.remove('hidden');
            renderImageAssociationQuestion(data);
            break;
          case 'multiple_choice':
          default:
            // Default: render as multiple choice
            questionCard.classList.remove('hidden');
            renderMultipleChoiceQuestion(data);
            break;
        }

        // Update progress in header
        const currentQuestionNum = document.getElementById('currentQuestionNum');
        const totalQuestionsNum = document.getElementById('totalQuestionsNum');
        const progressBar = document.getElementById('progressBar');

        if (currentQuestionNum) currentQuestionNum.textContent = currentQuestion;
        if (totalQuestionsNum && totalQuestions) totalQuestionsNum.textContent = totalQuestions;

        if (progressBar && totalQuestions) {
          progressBar.style.width = `${(currentQuestion / totalQuestions) * 100}%`;
        }

        // Update question type badge
        const questionTypeBadge = document.getElementById('questionType');
        if (questionTypeBadge) {
          const typeLabels = {
            'multiple_choice': 'üìù Multiple Choice',
            'fill_gap': '‚úèÔ∏è Fill Gap',
            'true_false': '‚úì True/False',
            'matching': 'üîó Matching',
            'image_association': 'üñºÔ∏è Image Association',
            'sentence_ordering': 'üìã Sentence Ordering',
            'grammar_choice': 'üìñ Grammar Choice',
            'error_correction': '‚úÇÔ∏è Error Correction',
            'cloze_test': 'üìù Cloze Test',
            'dictation': 'üéß Dictation',
            'audio_comprehension': 'üéµ Audio Comprehension',
            'audio_to_word': 'üîä Audio to Word',
            'repeat_after_me': 'üó£Ô∏è Repeat After Me'
          };
          questionTypeBadge.textContent = typeLabels[data.questionType] || 'üìù Question';
        }

        answered = false;
        nextBtn.disabled = true;
      } catch (error) {
        console.error('Failed to load question:', error);
        console.error('Error details:', {
          message: error.message,
          stack: error.stack,
          API_CONFIG_exists: typeof API_CONFIG !== 'undefined',
          telegramAuth_exists: typeof telegramAuth !== 'undefined'
        });

        // If it's a "no questions available" error, re-throw it
        if (error.message && error.message.includes('No quiz questions available')) {
          throw error;
        }

        alert(`Failed to load question: ${error.message}\n\nPlease check your internet connection and try again.`);
        throw error;
      }
    }

    // Render multiple choice question
    function renderMultipleChoiceQuestion(data) {
      const options = data.options;

      let html = '<div class="space-y-3">';
      options.forEach((opt, index) => {
        const optId = String.fromCharCode(97 + index); // a, b, c, d
        html += `<div onclick="selectOption(this, '${opt}')" class="option-card rounded-xl p-4 flex items-center gap-3" data-option="${opt}">
          <div class="w-8 h-8 rounded-full border-2 border-gray-300 flex items-center justify-center">
            <span class="font-semibold text-gray-600">${optId.toUpperCase()}</span>
          </div>
          <span class="text-base font-medium">${opt}</span>
        </div>`;
      });
      html += '</div>';

      optionsContainer.innerHTML = html;
    }

    // Render matching question with dropdown pairs
    function renderMatchingQuestion(data) {
      // Parse options as pairs if they're a string
      let pairs = data.options;
      if (typeof pairs === 'string') {
        try {
          pairs = JSON.parse(pairs);
        } catch (e) {
          console.error('Failed to parse matching pairs:', e);
          return;
        }
      }

      if (!Array.isArray(pairs) || pairs.length === 0) {
        console.error('Invalid matching pairs data');
        return;
      }

      // Shuffle the right side options
      const rightOptions = pairs.map(p => p.right || p.english).sort(() => Math.random() - 0.5);

      pairs.forEach((pair, index) => {
        const pairContainer = document.createElement('div');
        pairContainer.className = 'flex items-center gap-3 mb-3';

        // Left side (Chinese or term)
        const leftBox = document.createElement('div');
        leftBox.className = 'flex-1 p-4 rounded-xl bg-blue-50 dark:bg-blue-900/20 font-bold text-xl text-center border-2 border-blue-200 dark:border-blue-800';
        leftBox.textContent = pair.left || pair.chinese;

        // Right side (dropdown)
        const select = document.createElement('select');
        select.id = `match_${index}`;
        select.className = 'flex-1 p-4 rounded-xl border-2 border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-text-light dark:text-text-dark font-medium';
        select.onchange = checkMatchingComplete;

        // Add placeholder option
        const placeholderOption = document.createElement('option');
        placeholderOption.value = '';
        placeholderOption.textContent = 'Select...';
        select.appendChild(placeholderOption);

        // Add all options
        rightOptions.forEach(rightText => {
          const option = document.createElement('option');
          option.value = rightText;
          option.textContent = rightText;
          select.appendChild(option);
        });

        pairContainer.appendChild(leftBox);
        pairContainer.appendChild(select);
        optionsContainer.appendChild(pairContainer);
      });
    }

    // Render cloze test question
    function renderClozeTestQuestion(data) {
      console.log('Rendering cloze test with data:', data);
      console.log('data.options type:', typeof data.options);
      console.log('data.options value:', data.options);

      // Extract passage from question text
      const passageMatch = data.question.match(/\[passage:\s*(.+?)\]$/);
      if (!passageMatch) {
        console.error('No passage found in cloze test question');
        return;
      }

      const passage = passageMatch[1];

      // Extract question heading (text before [passage:...])
      const questionHeading = data.question.replace(/\[passage:.+?\]$/g, '').trim();

      // Parse blanks from options
      let blanks = [];
      if (typeof data.options === 'string') {
        try {
          blanks = JSON.parse(data.options);
          console.log('Parsed blanks from string:', blanks);
        } catch (e) {
          console.error('Failed to parse blanks:', e);
          return;
        }
      } else {
        blanks = data.options;
        console.log('Using blanks directly:', blanks);
      }

      if (!Array.isArray(blanks) || blanks.length === 0) {
        console.error('Invalid blanks data:', blanks);
        return;
      }

      console.log('Final blanks array:', blanks);

      // Build HTML - heading, passage, then input fields (matching reference exactly)
      let html = `<div class="space-y-4">
        <h2 class="text-xl font-bold mb-4">${questionHeading}</h2>
        <div class="p-6 rounded-xl bg-gray-50 dark:bg-gray-800">
          <p class="text-2xl leading-relaxed mb-4">${passage}</p>
        </div>
        <div class="space-y-3">`;

      blanks.forEach((blank, index) => {
        html += `<div>
          <label class="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Blank ${index + 1}:</label>
          <input type="text" id="blank_${index}" class="w-full px-4 py-3.5 rounded-xl border-2 border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all text-base" placeholder="Type answer..." oninput="handleClozeChange()">
        </div>`;
      });

      html += '</div></div>';

      optionsContainer.innerHTML = html;

      // Store blanks data for validation
      window.clozeTestBlanks = blanks;
    }

    // Render fill in the gap question
    function renderFillGapQuestion(data) {
      // Extract sentence from question format: "heading - sentence (translation)"
      let sentence = data.sentence || data.question;
      let translation = data.translation || '';

      // If question contains " - ", extract the sentence part after the dash
      const dashMatch = sentence.match(/^.+?\s*-\s*(.+)$/);
      if (dashMatch) {
        sentence = dashMatch[1].trim();
      }

      // Extract translation from parentheses at the end of sentence
      if (!translation) {
        const translationMatch = sentence.match(/\s*\((.+?)\)\s*$/);
        if (translationMatch) {
          translation = translationMatch[1].trim();
          sentence = sentence.replace(/\s*\(.+?\)\s*$/, '').trim();
        }
      }

      let html = `<div class="space-y-4">
        <div class="p-6 rounded-xl bg-gray-50 dark:bg-gray-800 text-center mb-4">
          <p class="text-3xl font-bold mb-2">${sentence}</p>
          ${translation ? `<p class="text-sm text-gray-500">${translation}</p>` : ''}
        </div>
        <div>
          <label class="block text-sm font-medium mb-2">Your answer:</label>
          <input type="text" id="gapInput" class="input-box" placeholder="Type your answer here..." oninput="handleInputChange()">
        </div>
      </div>`;

      optionsContainer.innerHTML = html;
    }

    // Render true/false question
    function renderTrueFalseQuestion(data) {
      const statement = data.statement || data.question;

      let html = `<div class="space-y-4">
        <div class="p-6 rounded-xl bg-gray-50 dark:bg-gray-800 text-center mb-6">
          <p class="text-2xl font-bold">${statement}</p>
        </div>
        <div class="space-y-3">
          <div onclick="selectTrueFalse(true)" class="option-card rounded-xl p-5 flex items-center gap-3" data-option="true">
            <span class="material-symbols-outlined text-green-500 text-3xl">check_circle</span>
            <span class="text-lg font-semibold">True</span>
          </div>
          <div onclick="selectTrueFalse(false)" class="option-card rounded-xl p-5 flex items-center gap-3" data-option="false">
            <span class="material-symbols-outlined text-red-500 text-3xl">cancel</span>
            <span class="text-lg font-semibold">False</span>
          </div>
        </div>
      </div>`;

      optionsContainer.innerHTML = html;
    }

    // Render sentence ordering question
    function renderSentenceOrderingQuestion(data) {
      const words = data.words || data.options;
      const translation = data.translation || '';

      // Shuffle words
      const shuffled = [...words].sort(() => Math.random() - 0.5);

      let html = `<div class="space-y-4">
        ${translation ? `<p class="text-sm text-gray-500 mb-2">${translation}</p>` : ''}
        <div class="drop-zone mb-4" id="dropZone" ondrop="drop(event)" ondragover="allowDrop(event)">
          <p class="text-gray-400 text-sm">Drop words here in correct order</p>
        </div>
        <div class="flex flex-wrap gap-3" id="wordBank">`;

      shuffled.forEach((word, index) => {
        html += `<div class="word-chip" draggable="true" ondragstart="drag(event)" id="word_${index}" data-word="${word}">
          <span class="text-lg font-bold">${word}</span>
        </div>`;
      });

      html += '</div></div>';
      optionsContainer.innerHTML = html;
    }

    // Render grammar choice question
    function renderGrammarChoiceQuestion(data) {
      const sentence = data.sentence || data.question;
      const options = data.options;

      let html = `<div class="space-y-4">
        <div class="p-6 rounded-xl bg-gray-50 dark:bg-gray-800 text-center mb-6">
          <p class="text-3xl font-bold">${sentence}</p>
        </div>
        <div class="space-y-3">`;

      options.forEach((opt, index) => {
        html += `<div onclick="selectOption(this, '${opt}')" class="option-card rounded-xl p-5 text-center" data-option="${opt}">
          <span class="text-2xl font-bold">${opt}</span>
        </div>`;
      });

      html += '</div></div>';
      optionsContainer.innerHTML = html;
    }

    // Render error correction question
    function renderErrorCorrectionQuestion(data) {
      const sentence = data.sentence || data.options;

      let html = `<div class="space-y-4">
        <p class="text-sm text-gray-500 mb-4">Tap the word that is in the wrong position:</p>
        <div class="p-6 rounded-xl bg-gray-50 dark:bg-gray-800 text-center">
          <div class="flex justify-center gap-2 flex-wrap">`;

      sentence.forEach((word, index) => {
        html += `<span class="error-text text-2xl font-bold px-2 py-1" onclick="selectError(${index})" data-index="${index}">${word}</span>`;
      });

      html += `</div></div>
        <div id="correctionInput" class="hidden mt-4">
          <p class="text-sm font-medium mb-2">Drag to reorder:</p>
          <div class="drop-zone" id="correctionZone"></div>
        </div>
      </div>`;

      optionsContainer.innerHTML = html;
    }

    // Render dictation question
    function renderDictationQuestion(data) {
      let html = `<div class="space-y-4">
        <div>
          <label class="block text-sm font-medium mb-2">Type what you hear:</label>
          <input type="text" id="dictationInput" class="input-box" placeholder="Type here..." oninput="handleInputChange()">
        </div>
      </div>`;

      optionsContainer.innerHTML = html;
    }

    // Render audio comprehension question
    function renderAudioComprehensionQuestion(data) {
      const comprehensionQuestion = data.comprehensionQuestion || data.question;
      const options = data.options;

      let html = `<div class="space-y-4">
        <p class="font-semibold mb-3">${comprehensionQuestion}</p>
        <div class="space-y-3">`;

      options.forEach((opt, index) => {
        const optId = String.fromCharCode(97 + index); // a, b, c, d
        html += `<div onclick="selectOption(this, '${opt}')" class="option-card rounded-xl p-4 flex items-center gap-3" data-option="${opt}">
          <div class="w-8 h-8 rounded-full border-2 border-gray-300 flex items-center justify-center">
            <span class="font-semibold text-gray-600">${optId.toUpperCase()}</span>
          </div>
          <span class="text-base font-medium">${opt}</span>
        </div>`;
      });

      html += '</div></div>';
      optionsContainer.innerHTML = html;
    }

    // Render audio to word question (listen and select the word you hear)
    function renderAudioToWordQuestion(data) {
      const options = data.options;

      let html = `<div class="space-y-4">
        <div class="space-y-3">`;

      options.forEach(opt => {
        const parts = opt.split(' - ');
        const chinese = parts[0];
        const rest = parts.slice(1).join(' - ');

        html += `<div onclick="selectOption(this, '${opt}')" class="option-card rounded-xl p-4" data-option="${opt}">
          <p class="text-2xl font-bold mb-1">${chinese}</p>
          ${rest ? `<p class="text-sm text-gray-500">${rest}</p>` : ''}
        </div>`;
      });

      html += '</div></div>';
      optionsContainer.innerHTML = html;
    }

    // Render repeat after me question
    function renderRepeatAfterMeQuestion(data) {
      const targetPhrase = data.targetPhrase || data.chinese || data.question;
      const pinyin = data.pinyin || '';
      const translation = data.translation || '';

      let html = `<div class="space-y-4">
        <div class="flex flex-col items-center gap-4 my-8">
          <p class="text-sm font-medium">Now you try! Press and hold to record:</p>
          <button id="recordBtn" class="record-button" onmousedown="startRecording()" onmouseup="stopRecording()" ontouchstart="startRecording()" ontouchend="stopRecording()">
            <span class="material-symbols-outlined text-white text-4xl">mic</span>
          </button>
          <p id="recordStatus" class="text-xs text-gray-500">Press to start recording</p>
        </div>
      </div>`;

      optionsContainer.innerHTML = html;
    }

    // Render image association question
    function renderImageAssociationQuestion(data) {
      const options = data.options;

      let html = `<div class="space-y-4">
        <div class="space-y-3">`;

      options.forEach((opt, index) => {
        html += `<div onclick="selectOption(this, '${opt}')" class="option-card rounded-xl p-4 flex items-center justify-center gap-3" data-option="${opt}">
          <span class="text-2xl font-bold">${opt}</span>
        </div>`;
      });

      html += '</div></div>';
      optionsContainer.innerHTML = html;
    }

    // Handle cloze test input change (check if all blanks filled)
    function handleClozeChange() {
      const blanks = window.clozeTestBlanks || [];
      let allFilled = true;
      blanks.forEach((_, index) => {
        const input = document.getElementById(`blank_${index}`);
        if (!input || !input.value.trim()) allFilled = false;
      });
      if (allFilled) {
        nextBtn.disabled = false;
        // Don't auto-submit - let user review answers and click Next button
      } else {
        nextBtn.disabled = true;
      }
    }

    // Legacy alias
    function checkClozeComplete() {
      handleClozeChange();
    }

    // Check if all matching pairs are selected
    function checkMatchingComplete() {
      const selects = optionsContainer.querySelectorAll('select');
      let allSelected = true;
      selects.forEach(select => {
        if (!select.value) allSelected = false;
      });

      if (allSelected) {
        nextBtn.disabled = false;
        // Auto-submit matching answer
        submitMatchingAnswer();
      }
    }

    // Submit matching answer
    async function submitMatchingAnswer() {
      if (answered) return;
      answered = true;

      // Parse pairs from original data
      let pairs = currentQuestionData.options;
      if (typeof pairs === 'string') {
        pairs = JSON.parse(pairs);
      }

      // Check each match
      const selects = optionsContainer.querySelectorAll('select');
      let allCorrect = true;

      selects.forEach((select, index) => {
        const correctAnswer = pairs[index].right || pairs[index].english;
        const userAnswer = select.value;
        const isCorrect = userAnswer === correctAnswer;

        if (!isCorrect) allCorrect = false;

        // Visual feedback
        if (isCorrect) {
          select.classList.add('!border-green-500', '!bg-green-50', 'dark:!bg-green-900/20');
        } else {
          select.classList.add('!border-red-500', '!bg-red-50', 'dark:!bg-red-900/20');
        }
        select.disabled = true;
      });

      // Update stats
      if (allCorrect) {
        stats.correct++;
      } else {
        stats.incorrect++;
      }

      // Save progress
      if (currentQuestionData && telegramAuth.isAuthenticated()) {
        try {
          await fetch(API_CONFIG.url('/api/progress/quiz'), {
            method: 'POST',
            headers: telegramAuth.getHeaders(),
            body: JSON.stringify({
              vocabularyId: currentQuestionData.id,
              correct: allCorrect
            })
          });
        } catch (error) {
          console.error('Failed to save progress:', error);
        }
      }

      updateStats();
    }

    // Submit cloze test answer
    async function submitClozeTestAnswer() {
      if (answered) return;
      answered = true;

      const blanks = window.clozeTestBlanks || [];
      const inputs = optionsContainer.querySelectorAll('input[type="text"]');
      let allCorrect = true;

      inputs.forEach((input, index) => {
        const userAnswer = input.value.trim().toLowerCase();
        const blankData = blanks[index];

        if (!blankData) {
          console.error('No blank data for index', index);
          allCorrect = false;
          return;
        }

        const correctAnswer = blankData.correct.toLowerCase();
        const acceptableAnswers = (blankData.acceptable || []).map(a => a.toLowerCase());

        console.log(`Blank ${index + 1}:`, {
          userAnswer,
          correctAnswer,
          acceptableAnswers,
          blankData
        });

        // Check if user answer matches correct answer or any acceptable alternatives
        const isCorrect = userAnswer === correctAnswer || acceptableAnswers.includes(userAnswer);

        console.log(`Blank ${index + 1} is ${isCorrect ? 'CORRECT' : 'INCORRECT'}`);

        if (!isCorrect) allCorrect = false;

        // Visual feedback
        if (isCorrect) {
          input.classList.remove('border-blue-500');
          input.classList.add('border-green-500', 'bg-green-50', 'dark:bg-green-900/20');
        } else {
          input.classList.remove('border-blue-500');
          input.classList.add('border-red-500', 'bg-red-50', 'dark:bg-red-900/20');
          // Show correct answer
          const correctSpan = document.createElement('span');
          correctSpan.className = 'ml-2 text-green-600 dark:text-green-400 font-bold';
          correctSpan.textContent = `‚úì ${blankData.correct}`;
          input.parentNode.insertBefore(correctSpan, input.nextSibling);
        }
        input.disabled = true;
      });

      // Update stats
      if (allCorrect) {
        stats.correct++;
      } else {
        stats.incorrect++;
      }

      // Save progress
      if (currentQuestionData && telegramAuth.isAuthenticated()) {
        try {
          await fetch(API_CONFIG.url('/api/progress/quiz'), {
            method: 'POST',
            headers: telegramAuth.getHeaders(),
            body: JSON.stringify({
              vocabularyId: currentQuestionData.id,
              correct: allCorrect
            })
          });
        } catch (error) {
          console.error('Failed to save progress:', error);
        }
      }

      updateStats();
    }

    // Handle option selection
    async function selectOption(selectedElement, selectedAnswer) {
      if (answered) return;

      // Remove previous selection
      document.querySelectorAll('.option-card, .option-btn').forEach(card => {
        card.classList.remove('selected');
      });

      // Mark as selected
      selectedElement.classList.add('selected');

      answered = true;
      nextBtn.disabled = false;

      // Check answer
      const isCorrect = selectedAnswer === currentAnswer;

      // Save progress to backend
      if (currentQuestionData && telegramAuth.isAuthenticated()) {
        try {
          await fetch(API_CONFIG.url('/api/progress/quiz'), {
            method: 'POST',
            headers: telegramAuth.getHeaders(),
            body: JSON.stringify({
              vocabularyId: currentQuestionData.id,
              correct: isCorrect
            })
          });
        } catch (error) {
          console.error('Failed to save progress:', error);
        }
      }

      if (isCorrect) {
        selectedElement.classList.remove('selected');
        selectedElement.classList.add('correct');
        stats.correct++;
      } else {
        selectedElement.classList.remove('selected');
        selectedElement.classList.add('wrong');
        stats.incorrect++;

        // Highlight correct answer
        const options = optionsContainer.querySelectorAll('.option-btn, .option-card');
        options.forEach(opt => {
          const optText = opt.textContent.trim();
          // Remove letter prefix (A, B, C, D) if present
          const cleanText = optText.replace(/^[A-Z]\s*/, '').trim();
          if (cleanText === currentAnswer || optText === currentAnswer) {
            opt.classList.add('correct');
          }
        });
      }

      // Disable all options
      const options = optionsContainer.querySelectorAll('.option-btn, .option-card');
      options.forEach(opt => {
        opt.style.pointerEvents = 'none';
      });

      updateStats();
    }

    // Select true/false option
    function selectTrueFalse(value) {
      const element = document.querySelector(`[data-option="${value}"]`);
      if (element) {
        selectOption(element, value.toString());
      }
    }

    // Handle input change for fill gap and dictation
    function handleInputChange() {
      const input = document.getElementById('gapInput') || document.getElementById('dictationInput');
      if (input && input.value.trim()) {
        nextBtn.disabled = false;
      }
    }

    // Select error for error correction
    let selectedErrorIndex = null;
    function selectError(index) {
      document.querySelectorAll('.error-text').forEach(el => el.classList.remove('selected'));
      document.querySelector(`[data-index="${index}"]`).classList.add('selected');
      selectedErrorIndex = index;
      nextBtn.disabled = false;
    }

    // Drag and drop handlers for sentence ordering
    let draggedElement = null;
    let orderedWords = [];

    function allowDrop(ev) {
      ev.preventDefault();
      ev.target.closest('.drop-zone')?.classList.add('active');
    }

    function drag(ev) {
      draggedElement = ev.target;
      ev.dataTransfer.effectAllowed = 'move';
    }

    function drop(ev) {
      ev.preventDefault();
      const dropZone = document.getElementById('dropZone');
      if (!dropZone) return;

      dropZone.classList.remove('active');

      if (draggedElement) {
        // Clear placeholder text if present
        const placeholder = dropZone.querySelector('p');
        if (placeholder) placeholder.remove();

        dropZone.appendChild(draggedElement);
        draggedElement.style.cursor = 'move';

        // Update ordered words
        orderedWords = Array.from(dropZone.querySelectorAll('.word-chip')).map(chip => chip.dataset.word);

        // Check if all words are in drop zone
        const wordBank = document.getElementById('wordBank');
        if (wordBank && wordBank.children.length === 0) {
          nextBtn.disabled = false;
        }
      }
    }

    // Recording functions for repeat after me
    let isRecording = false;
    function startRecording() {
      isRecording = true;
      const recordBtn = document.getElementById('recordBtn');
      const recordStatus = document.getElementById('recordStatus');
      if (recordBtn) recordBtn.classList.add('recording');
      if (recordStatus) recordStatus.textContent = 'Recording...';
    }

    function stopRecording() {
      if (isRecording) {
        isRecording = false;
        const recordBtn = document.getElementById('recordBtn');
        const recordStatus = document.getElementById('recordStatus');
        if (recordBtn) recordBtn.classList.remove('recording');
        if (recordStatus) recordStatus.textContent = 'Processing...';
        nextBtn.disabled = false;
        setTimeout(() => {
          if (recordStatus) recordStatus.textContent = 'Recording complete!';
        }, 1000);
      }
    }

    // Update stats (simplified - no UI elements to update now)
    function updateStats() {
      // Stats are tracked in the stats object and shown at quiz completion
      console.log('Stats updated:', stats);
    }

    // Next question
    nextBtn.addEventListener('click', async () => {
      if (quizComplete) {
        finishQuiz();
        return;
      }

      // If this is a cloze test and not yet answered, submit the answer first
      if (currentQuestionData?.questionType === 'cloze_test' && !answered) {
        await submitClozeTestAnswer();
      }

      // If this is a matching question and not yet answered, submit the answer first
      if (currentQuestionData?.questionType === 'matching' && !answered) {
        await submitMatchingAnswer();
      }

      currentQuestion++;

      // Try to load next question
      try {
        await loadQuestion();
      } catch (error) {
        // If we can't load more questions, the quiz is complete
        console.log('No more questions available, finishing quiz');
        quizComplete = true;
        totalQuestions = currentQuestion - 1; // Set total to actual questions answered
        finishQuiz();
      }
    });

    function finishQuiz() {
      // End study tracking session
      if (typeof studyTracker !== 'undefined') {
        const minutes = studyTracker.endSession();
        console.log(`Quiz session completed: ${minutes} minutes`);
      }

      const total = stats.correct + stats.incorrect;
      const accuracy = total > 0 ? Math.round((stats.correct / total) * 100) : 0;
      alert(`Quiz Complete! üéâ\n\nScore: ${stats.correct * 10}/${total * 10}\nCorrect: ${stats.correct}\nIncorrect: ${stats.incorrect}\nAccuracy: ${accuracy}%`);
      window.location.href = '/practice.html';
    }

    // Back button
    backBtn.addEventListener('click', () => {
      // End study session if user leaves early
      if (typeof studyTracker !== 'undefined') {
        studyTracker.endSession();
      }
      window.history.back();
    });

    // Also track when user leaves page (browser back, close, etc.)
    window.addEventListener('beforeunload', () => {
      if (typeof studyTracker !== 'undefined' && studyTracker.currentSession) {
        studyTracker.endSession();
      }
    });

    // Initialize when page is fully loaded
    window.addEventListener('DOMContentLoaded', () => {
      // Start tracking study time
      if (typeof studyTracker !== 'undefined') {
        studyTracker.startSession('quiz');
      }
      
      // Load first question
      loadQuestion();
    });
  </script>
</body>
</html>
